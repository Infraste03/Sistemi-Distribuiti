/**
 * @author Francesca Stefano mat. 353310
 * The Server class in the acquistoProdotti_JMS package implements a JMS server that receives offers
 * from clients, processes them, and publishes prices periodically.
 */

package acquistoProdotti_JMS;

import jakarta.jms.Destination;
import jakarta.jms.JMSException;
import jakarta.jms.Message;
import jakarta.jms.MessageConsumer;
import jakarta.jms.MessageListener;
import jakarta.jms.MessageProducer;
import jakarta.jms.Queue;
import jakarta.jms.QueueSession;
import jakarta.jms.Session;
import jakarta.jms.TextMessage;
import jakarta.jms.Topic;
import jakarta.jms.TopicPublisher;
import jakarta.jms.TopicSession;

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

import org.apache.activemq.ActiveMQConnection;
import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.broker.BrokerFactory;
import org.apache.activemq.broker.BrokerService;

/**
 * The `Server` class in Java implements a message listener for handling client
 * connections, receiving
 * offers, and publishing server prices in a messaging system using Apache
 * ActiveMQ.
 */

public class Server implements MessageListener {
    private static final String BROKER_URL_PUB = "tcp://localhost:61616";
    private static final String BROKER_PROPS = "persistent=false&useJmx=false";
    private static final String QUEUE_NAME = "server";
    private static final String QUEUE_NAME1 = "server1";
    /** list with the ID clients */
    private Set<String> clientIds = new HashSet<>();
    /** boolean variable to start the operation */
    private boolean start = false;

    private static final String TOPIC_NAME = "topic";
    private static int MAX = 200;
    private static int MIN = 10;
    /* *Object Random to generate the price */
    Random r = new Random();
    /** varibale for the price generated by server */
    private int serverPrice;

    private static final int NUMCLIENT = 3;

    /** Object for the connection of ActiveMQConnection */
    private ActiveMQConnection connection = null;
    /** Object for the session of connection */
    private QueueSession session = null;
    /** consumer message */
    private MessageConsumer consumer = null;

    /**
     * The `receiveOffer` function sets up a server to listen for messages from
     * clients using ActiveMQ
     * messaging.
     */

    public void receiveOffer() {
        System.out.println("####SERVER ON####");

        try {
            BrokerService broker = BrokerFactory.createBroker(
                    "broker:(" + BROKER_URL_PUB + ")?" + BROKER_PROPS);

            broker.start();

            ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(Server.BROKER_URL_PUB);

            connection = (ActiveMQConnection) cf.createConnection();

            connection.start();

            session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

            Queue queue = session.createQueue(QUEUE_NAME); // Listen on the same queue that the clients are sending
                                                           // messages on

            consumer = session.createConsumer(queue);

            consumer.setMessageListener(this);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * The `addClient` function creates a unique queue for a client using ActiveMQ
     * and sets up a message
     * listener for that queue.
     * 
     * @param clientId The `clientId` parameter in the `addClient` method is used to
     *                 uniquely identify a
     *                 client and create a unique queue for that client in ActiveMQ.
     *                 This allows messages to be sent and
     *                 received specifically for that client.
     */

    public void addClient(String clientId) {
        try {
            ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(Server.BROKER_URL_PUB);

            connection = (ActiveMQConnection) cf.createConnection();

            connection.start();

            session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

            Queue queue = session.createQueue(QUEUE_NAME1 + "_" + clientId); // Creare una coda unica per il client

            consumer = session.createConsumer(queue);

            consumer.setMessageListener(this);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * The `onMessage` method in the `Server` class is an overridden method from the
     * `MessageListener`
     * interface. This method is called when a message is received by the message
     * consumer associated with
     * the server.
     * 
     * @param m the message to be received by the message consumer
     */
    /** {@inheritDoc} **/
    @Override
    public void onMessage(final Message m) {
        try {
            if (m instanceof TextMessage && "Client connected".equals(((TextMessage) m).getText())) {
                String clientId = m.getStringProperty("ClientId");

                System.out.println("Connected Client Id " + clientId);

                clientIds.add(clientId);

                this.addClient(clientId);
            }

            if (clientIds.size() >= NUMCLIENT || start) {

                start = true;

                if (m.propertyExists("Prezzo")) {

                    try {

                        System.out.println("Received offer from client: " + ((Message) m).getIntProperty("Prezzo"));

                        if (m.getIntProperty("Prezzo") >= serverPrice) {
                            TextMessage message = session.createTextMessage();
                            message.setText("OK");
                            System.out.println("OK " + serverPrice);

                            Destination d = m.getJMSReplyTo();
                            MessageProducer producer = session.createProducer(d);
                            message.setJMSCorrelationID(m.getJMSCorrelationID());
                            producer.send(message);

                        } else {
                            TextMessage message = session.createTextMessage();
                            message.setText("NOT OK");
                            System.out.println("NOT OK " + serverPrice);

                            Destination d = m.getJMSReplyTo();
                            MessageProducer producer = session.createProducer(d);
                            message.setJMSCorrelationID(m.getJMSCorrelationID());
                            producer.send(message);

                        }

                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                }

                if (m.propertyExists("Fine")) {

                    try {

                        System.out.println("Disconnection client ID " + ((Message) m).getIntProperty("Fine"));

                        String clientId = m.getStringProperty("Fine");

                        clientIds.remove(clientId);

                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                }
            }

            if (clientIds.size() == 0) {
                start = false;
                System.out.println("#######TERMINATED SERVER####### ");
                try {
                    Thread.sleep(1000);
                    connection.close();
                    System.exit(0);
                } catch (JMSException e) {
                    e.printStackTrace();
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

            }

        } catch (JMSException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    /**
     * The `publish` method creates a JMS session to publish messages with a
     * generated price to a topic at
     * regular intervals, handling exceptions and adding a delay between
     * publications.
     */

    public void publish() {
        try {
            TopicSession sessionT = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
            Topic topic = sessionT.createTopic(TOPIC_NAME);
            TopicPublisher publisher = sessionT.createPublisher(topic);

            while (true) {
                TextMessage message = sessionT.createTextMessage();
                serverPrice = (r.nextInt(MAX - MIN) + MIN);
                message.setText("The price is: " + serverPrice);
                publisher.publish(message);
                System.out.println("Price generated from server: " + serverPrice);

                Thread.sleep(4000); // Aggiungi un ritardo prima della prossima pubblicazione
            }
        } catch (InterruptedException e) {
            // Gestisci l'interruzione del thread
            Thread.currentThread().interrupt();
        } catch (JMSException e) {
            e.printStackTrace(); // Gestisci le eccezioni JMS
        }
    }

    /**
     * The main function creates a Server object, receives an offer, and then
     * publishes it.
     * 
     * @param args The `args` parameter in the `main` method is an array of strings
     *             that allows you to pass
     *             command-line arguments when running the Java program. These
     *             arguments can be accessed within the
     *             `main` method and used for various purposes, such as configuring
     *             the program behavior or providing
     *             input data.
     */

    public static void main(final String[] args) {
        Server s = new Server();
        s.receiveOffer();
        s.publish();

    }

}